{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/EtherealStates/EtherealStatesDNA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/// @title EtherealStatesDNA\n/// @author Artist: GenuineHumanArt (https://twitter.com/GenuineHumanArt)\n/// @author Developer: dievardump (https://twitter.com/dievardump, dievardump@gmail.com)\n/// @notice Generates DNA for EtherealStates NFTs\n///         A big thank you to cxkoda (https://twitter.com/cxkoda) who helped me with the bit manipulation\n///         & assembly and saved quite some gas.\ncontract EtherealStatesDNA {\n    error WrongDistributionForLayer(uint256 layer, uint256 acc);\n\n    function checkLayersValidity() public pure {\n        unchecked {\n            bytes memory layer;\n            uint256 acc;\n            uint256 i;\n            for (uint256 j; j < 20; j++) {\n                layer = getLayer(j);\n                acc = 0;\n                assembly {\n                    for {\n                        let current := add(layer, 0x20)\n                        let length := mload(layer)\n                    } lt(i, length) {\n                        current := add(current, 2)\n                        i := add(i, 2)\n                    } {\n                        acc := add(acc, sar(240, mload(current)))\n                    }\n                    i := 0\n                }\n\n                if (acc != 10000) {\n                    revert WrongDistributionForLayer(j, acc);\n                }\n            }\n        }\n    }\n\n    function generate(uint256 seed, bool includeHolderTraits)\n        public\n        pure\n        returns (bytes32)\n    {\n        uint256 dna;\n        uint256 random;\n\n        unchecked {\n            for (uint256 i; i < 20; i++) {\n                // keccak the seed, very simple prng\n                // we do it on each call, because even if Holders layer is not shown we want to be sure\n                // the layers after stay the same with or without it\n                seed = uint256(keccak256(abi.encode(seed)));\n\n                // next random number\n                random = seed % 10000;\n\n                // push 8 null bits on the right side\n                dna <<= 8;\n\n                // done here and not in consumer, because getLayer(i) and pickOne are costly operations.\n                // this way we save the gas when the trait is not included\n                if (i != 12 || includeHolderTraits) {\n                    // set the last 8 bits to the index of the asset in the layer\n                    dna |= _pickOne(getLayer(i), random);\n                }\n            }\n\n            // add 96 null bits right\n            dna <<= 96;\n        }\n        return bytes32(dna);\n    }\n\n    function _pickOne(bytes memory layer, uint256 chance)\n        public\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 i;\n            assembly {\n                for {\n                    let current := add(layer, 0x20)\n                    let acc\n                } 1 {\n                    // add 2 bytes to current position\n                    current := add(current, 2)\n                    i := add(i, 2)\n                } {\n                    // add the value of the 2 first bytes of current in acc\n                    acc := add(acc, sar(240, mload(current)))\n                    // if chance < acc\n                    if lt(chance, acc) {\n                        break\n                    }\n                }\n                i := sar(1, i)\n            }\n            return i;\n        }\n    }\n\n    // this is pretty dirty but this saves quite some gas\n    // 1) putting the layers in storage would be very expensive when deploying & when reading storage\n    // 2) using arrays of uint for that many assets (512), is too big for a contract\n    // After tests, this seems to be a good working compromise\n    function getLayer(uint256 which) public pure returns (bytes memory layer) {\n        if (which == 0)\n            layer = hex'01900190017c017c019001900006015e01900040017c00be0190000a0190015e017c017c0190015e001000680190017c0190017c00140020017c0087017c017c00df015e';\n        else if (which == 1)\n            layer = hex'012e0132007c00a0005e000a012c01e701e7000c000800b4006401e700a201e701e701e701e701bb01e701e7000e01e701b7000c01b701bb007c0130000e01e701e700a6';\n        else if (which == 2)\n            layer = hex'01b8019001b801b801a4011801cc01cc01cc0168001401cc01cc01b801cc01b801cc01b801b801b801b801cc01a401cc';\n        else if (which == 3)\n            layer = hex'004b003602080208020802080208004b00780208009102080110020802080208020801ae020801ae0208004f020802080208';\n        else if (which == 4)\n            layer = hex'007d004002080208020802080208004b020800a502080129020802080208020801c2020801c202080036020802080208';\n        else if (which == 5)\n            layer = hex'02260226021202120226021200d2012c022600aa02260096004002120212010400780212005602260212021202260226';\n        else if (which == 6)\n            layer = hex'01c201c200320064017201c201c20172001901c2017201720096017200960172003201c201c2017201c20064001901c2017201720064017201c201c2009601c2';\n        else if (which == 7)\n            layer = hex'00a01d4c005500780055009f00c700c7000700a000c700c7009f000500780055005500780005001e00c70078';\n        else if (which == 8)\n            layer = hex'01a901f401b301b301f401b301b301f401f4010e01f401f401b301f401b301f401a901f4005a01f40096001e01f401f4';\n        else if (which == 9)\n            layer = hex'020801b301b30208020801b300640208003c020800a001b301e501e501b30208015e020801b300c802080208015e0208';\n        else if (which == 10)\n            layer = hex'01e001fe019a019a01fe01e001fe01e0019a003201e001fe00960069004b01fe01fe01fe01fe01e001e001fe01fe019a';\n        else if (which == 11)\n            layer = hex'01f401f401f401f4012c01f40194019401e0001401e001f401f401e0000a019401e001e0019401f401f4019400fa01f4';\n        else if (which == 12)\n            layer = hex'0000032f032f032f032f032f032f01e00154032f01e00226032f032f032f';\n        else if (which == 13)\n            layer = hex'00780205020502050205008c01e002050205020501e0020500a000c001e001e00036020501e001e0020500fa02050205';\n        else if (which == 14)\n            layer = hex'020800be01e0020801e001fe01fe01e000fa003c01e0020800640208008c020801e00208020801e002080208020800a0';\n        else if (which == 15)\n            layer = hex'0194007801e0019401ea01ea01e00194000a019401ea01ea01ea01ea012c01e000fa01ea01ea01e001e001ea01ea0194';\n        else if (which == 16)\n            layer = hex'003201c2014301c201c2000a0143000f01c20143014301c200a000a00007005001c2003c00a001c2014301c201c201c201c201c201c201c2014301c201c200a0';\n        else if (which == 17)\n            layer = hex'00a00143005001a401a400f001a4006401a401a401a401a40143014301a4000a01a400f001a401a401a401a401a401a4014a01a400f000a0003c01430143002d';\n        else if (which == 18)\n            layer = hex'0143005001a401a401a4014301a40082002d01a4000a01a401a400f001a401a401a400a001a4004601a400a001a401430143014301a4017c00f001a4014a00f0';\n        else if (which == 19)\n            layer = hex'000a000a000a000a000a000a000a000a268e000a000a000a000a000a';\n    }\n}\n"
    }
  }
}